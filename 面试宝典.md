#面试宝典
@(读书笔记)[求职]

##约瑟夫环
我们把N个人从0~n-1编号，可得序列
0,1,2,3,4,5...n-2，n-1
我们第一次拿走第k个人，则可以得到其编号为
(k-1) % n
然后我们把剩下的人，按照
k%n=0
(k+1)%n=1
...
（k+n-2)%n=n-2
编号，同理可以得到n=n-1的情况下,第一个拿走的人的编号如果为p，那么实际上他在n=n的情况下偏移为(k+p)%n
显然当n=1时最后一个拿走的编号为0，我们定义为
$ans_1=0$
那么根据上面的结果我们可以知道当n=2时他的编号应当偏移为
$ans_2=(ans_1+k)  \%2 $
依次可以推出
$ans_n=(ans_{n-1}+k) \% n$

##Trie树
在单词搜索的时候可以根据前缀补齐后面的，用在搜索引擎上，可以统计和排序大量字符串

##大数据查找统计问题
1. 分组hash，然后在组内比较重复，最后扫一遍取出重复最多的几个
2. 抽样过滤大部分数据
3. 精髓在于内存中不能放下所有数据

##反射机制

Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。反射机制获取类的三种方法
```java
	//1 直接通过类名.Class的方式得到  
    clazz = Person.class;  
    System.out.println("通过类名: " + clazz);  
    //2 通过对象的getClass()方法获取,这个使用的少（一般是传的是Object，不知道是什么类型的时候才用）  
    Object obj = new Person();  
    clazz = obj.getClass();  
    System.out.println("通过getClass(): " + clazz);  
  
    //3 通过全类名获取，用的比较多，但可能抛出ClassNotFoundException异常  
    clazz = Class.forName("com.java.reflection.Person");  
    System.out.println("通过全类名获取: " + clazz);  
	//4. invoke调用方法
	Object obj = clazz.newInstance();  
    method2.invoke(obj, "changwen", 22);  
    //5、获取指定对象的Field的值  
    Object val = field.get(person);  
    //6. 获取注解  
    Annotation annotation = method.getAnnotation(AgeValidator.class);  
```

##控制反转和依赖注入

控制反转指将对象的创建交给特定的容器来做，依赖注入是容器可以自动的根据需要创建相应的类，同一个概念的不同表述

##消息队列
系统解耦：项目开始时，无法确定最终需求，不同进程间，添加一层，实现解耦，方便今后的扩展。生产者和消费者专注自己的工作即可。
消息缓存：系统中，不同进程处理消息速度不同，MQ，可以实现不同Process之间的缓冲，即，写入MQ的速度可以尽可能地快，而处理消息的速度可以适当调整（或快、或慢）。

##Kafka(消息队列)
主要由三部分组成，生产者、消费者和集群（包括多个分区），其中集群和消费者需要通过zookeeper交互
![kafka structure](https://images2017.cnblogs.com/blog/409917/201708/409917-20170808000013143-1162263091.png)

1. 高效性：消息集合压缩，还有备份机制。能够支持上千个客户端同时读写，kafka集群支持热扩展
2. 容错性：一个topic能有非常多个副本，如果服务器配置足够好，可以配很多个，副本的个数决定了有多少个broker存放写入的数据；简单的来说副本是以partition为单位的，存放副本也可以这样简单的理解，备份若干个partition、但是只能有一个partition被选为Leader用于读写。partition（分区）数量设置最好大于consumer数量，其实，这样设计的思想就是保证每个消费者都有一个partition。生产者在向kafka集群发送消息的时候，可以通过指定分区来发送到指定的分区中也可以通过指定均衡策略来将消息发送到不同的分区中如果不指定，就会采用默认的随机均衡策略，将消息随机的存储到不同的分区中，允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）
3. 持久性：消息持久化到本地
4. 高并发：支持数千个客户端同时读写

###设计思想
**Kakfa Broker Leader**的选举：Kakfa Broker集群受Zookeeper管理。所有的Kafka Broker节点一起去Zookeeper上注册一个临时节点，因为只有一个Kafka Broker会注册成功，其他的都会失败，所以这个成功在Zookeeper上注册临时节点的这个Kafka Broker会成为Kafka Broker Controller，其他的Kafka broker叫Kafka Broker follower。（这个过程叫Controller在ZooKeeper注册Watch）。这个Controller会监听其他的Kafka Broker的所有信息，如果这个kafka broker controller宕机了，在zookeeper上面的那个临时节点就会消失，此时所有的kafka broker又会一起去Zookeeper上注册一个临时节点，因为只有一个Kafka Broker会注册成功，其他的都会失败，所以这个成功在Zookeeper上注册临时节点的这个Kafka Broker会成为Kafka Broker Controller，其他的Kafka broker叫Kafka Broker follower。例如：一旦有一个broker宕机了，这个kafka broker controller会读取该宕机broker上所有的partition在zookeeper上的状态，并选取ISR列表中的一个replica作为partition leader（如果ISR列表中的replica全挂，选一个幸存的replica作为leader; 如果该partition的所有的replica都宕机了，则将新的leader设置为-1，等待恢复，等待ISR中的任一个Replica“活”过来，并且选它作为Leader；或选择第一个“活”过来的Replica（不一定是ISR中的）作为Leader），这个broker宕机的事情，kafka controller也会通知zookeeper，zookeeper就会通知其他的kafka broker。

**Consumergroup**：各个consumer（consumer 线程）可以组成一个组（Consumer group ），partition中的每个message只能被组（Consumer group ）中的一个consumer（consumer 线程）消费，如果一个message可以被多个consumer（consumer 线程）消费的话，那么这些consumer必须在不同的组。Kafka不支持一个partition中的message由两个或两个以上的同一个consumer group下的consumer thread来处理，除非再启动一个新的consumer group。所以如果想同时对一个topic做消费的话，启动多个consumer group就可以了，但是要注意的是，这里的多个consumer的消费都必须是顺序读取partition里面的message，新启动的consumer默认从partition队列最头端最新的地方开始阻塞的读message。

如果producer的流量增大，当前的topic的parition数量=consumer数量，这时候的应对方式就是很想扩展：增加topic下的partition，同时增加这个consumer group下的consumer。

kafka在性能上严重依赖文件系统的本身特性

除磁盘IO之外,我们还需要考虑网络IO,这直接关系到kafka的吞吐量问题.kafka并没有提供太多高超的技巧;对于producer端,可以将消息buffer起来,当消息的条数达到一定阀值时,批量发送给broker;对于consumer端也是一样,批量fetch多条消息

###使用场景
- 日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。
- 消息系统：解耦和生产者和消费者、缓存消息等。
- 用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。
- 运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。
- 流式处理：比如spark streaming和storm
- 事件源

#SPRING原理 

1.IOC控制反转

概念：控制权由对象本身转向容器，由容器根据配置文件创建对象实例并实现各个对象的依赖关系。

核心：bean工厂


2.AOP面向切面编程

a.静态代理

根据每个具体类分别编写代理类

根据一个接口编写一个代理类

b.动态代理

针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类，代理可以添加相应的拦截类在调用之前或者之后进行操作