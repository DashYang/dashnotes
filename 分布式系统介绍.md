#分布式系统介绍
@(读书笔记)[分布式|框架]
本文提到的分布式问题的关注点集中在分布式一致性上，试图通过一定的协议和算法，使得分布式系统对于客户端能够提供一致的存储状态。该类系统通常有这样的定义
1. 所有节点的初始状态一致
2. 如果每个节点按照同样的顺序执行一串操作序列，那么最终的状态一致（复制状态机）

通常这类分布式系统的关键在于分布式系统的**操作序列以同样的顺序执行**，主要通过各种时间戳仿照行为实现

##PAXOS
主要有两个角色：proposer和accpetor，proposer负责提出变更申请，而acceptor负责审核proposer提出来的变更请求，具体流程如图所示
![paxos](http://img.kuqin.com/upimg/allimg/141016/13003553S-0.png)
###阶段1
1. 一个proposer选择一个k值向大多数acceptor发出
2. acceptor根据接收到的k记录最大的给出承诺，不会接受比这个最大k小的请求
###阶段2
1. 当proposer接收到超过一半的同意请求，那么可以发出accpet请求，带上自己的V
2. accpetor只会接受当前最大的K，如果不是就拒绝accpet请求

从上面的过程需要注意几个点：
1. acceptor只会接受最大的k的proposal，但是proposal被拒绝了可以修改proposal的值重新发起，因此可能导致多个proposer不断的提交修改最大的K值从而永远无法被接收，这种情况称之为活锁，为了避免这种情况需要减少proposer，只推举少数leader
2. 每个proposer的k值需要唯一从而避免同样的k对应不同的v，其实这就是一种时间戳机制
zookeeper据说是通过该方法实现

*n/2+1节点正常就能够提供服务

##RAFT
跟paxos有点像却比paxos简单，RAFT吧PAXOS的leader优化发展到了极致，他的特点：
1. 强领导者（Strong Leader）：日志条目只从领导者发送向其他服务器。
2. 领导选取（Leader Selection）：Raft 使用随机定时器来选取领导者。

RAFT成员的三种状态：
1. leader：通过选举产生，接受所有客户端的同步请求再广播给所有follower
2. candidate：参加选举的服务器，选举成功后成为leader，这个状态持续时间一般非常短
3. follower：被动执行leader的请求

![转换关系](http://wx2.sinaimg.cn/mw690/4858d6a8ly1fc9uv9fx6wj20hn07xt9z.jpg)

RAFT通过任期（term，不断增加的数字）作为自己的时间戳，每个term的第一次操作都是选举leader，candidate只能给一个人投票‘，并且按照先来先投的原则，通过各种设定保证只能有一个人当选（随机超时，总有一个先达到“大多数”要求成为leader）。被选中的leader需要有完整（或者最完整）的操作列表。
选出leader后，leader开始接受客户端的请求，并且广播给所有follower进行appendEntries，只有当大多数follower执行该操作之后leader才会认为是commit的，如果有follower在commit之后被leader发现缺少操作也会被补操作。通常来说这种方式会保证leader和大多数follower的状态是一致的，但是在leader宕机follower还未执行完所有操作，可能会导致新选出来的leader和之前的leader的操作集存在一些问题，这个时候我们强制以新leader的操作集合为标准进行同步，因此leade是不会更改自己的操作集合的，只有follower为了完成一致而修改自己的操作集合。

*日志合并和快照机制来清理操作集合，n/2+1节点正常就能够提供服务

##PBFT

PBFT考虑的东西比PAXOS和RAFT多很多，因为他还考虑了节点不可信（发假消息，伪造消息）的情况，在失效节点不超过f（因为失效的节点可能会伪造消息，总节点至少为3f+1）的情况下仍能保持安全性和活性

PBFT算法的流程如下：
1. 客户端向主节点发送请求调用服务操作
2. 主节点通过广播将请求发送给其他副本
3. 所有副本都执行请求并将结果发回客户端
4. 客户端需要等待f+1个不同副本节点发回相同的结果，作为整个操作的最终结果。

某一段时间内以来主副本存在，主副本的作用在于将来自Client的请求给排好序，然后按序发送给备份节点们。但是主节点可能会是faulty的：它可能会给不同的请求编上相同的序号，或者不去分配序号，或者让相邻的序号不连续。备份节点应当有职责来主动检查这些序号的合法性，并能通过timeout机制检测到主节点是否已经宕掉。当出现这些异常情况时，这些备份节点就会触发view change协议来选举出新的主节点，p=v mod n v自增（类似RAFT的leader）。
quorums有两个重要的属性：（1）Intersection： 任意两个quorums至少有一个共同的并且正确的replica；（2）Availability: 总是存在一个没有faulty replicas的quorum
如果一个replica把信息写给一个quorum，并让该quorum来存储信息，在收到每一个quorum中的成员的确认反馈后，那么我们可以认为该replica的信息已经被可靠的保存在了这个分布式系统中。这是强的约束，当然还有一个weak certificates：就是至少f+1个节点来共同存取信息，这样至少有一个正确的replica存到了这份信息。
算法的要求：
（1）所有节点必须是确定性的。也就是说，在给定状态和参数相同的情况下，操作执行的结果必须相同；（2）所有节点必须从相同的状态开始执行。在这两个限定条件下，即使失效的副本节点存在，PBFT算法对所有非失效副本节点的请求执行总顺序达成一致，从而保证安全性。

流程
![](http://img.mp.itc.cn/upload/20170526/b6b2c783ac6f4c0687543a5fc82fa405_th.jpg)

1. pre-prepare主副本接收到客户端的请求后，会给操作分配一个序号，然后发给所有其他副本，其他副本判断这个消息是否正确，如果接受则进入下一个阶段，记录日志
2. prepare：其他副本验证pre-prepare消息正确后广播自己接受了该分配方式，同时副本也会收到prepare消息根据自己的进行比较（需要2f的其他副本同意）记录日志
3. commit：prepare通过之后，发送自己的commit请求，一旦接收到2f+1个其他副本的commit请求，那么就认为该操作被认可，执行该操作

尾声：所有成功执行的节点把结果发回给客户端，客户端收到f+1个结果可以正确判断

**垃圾回收**：在某个操作中设置保存点，清理保存点之间的操作记录
**自动切换主副本**：设置超时时间，当超过时候自动触发主副本切换

PBFT中消息的传递次数很多，不适合节点数目过多，对于带宽造成负担

