#分布式系统介绍
@(读书笔记)[分布式|框架]
本文提到的分布式问题的关注点集中在分布式一致性上，试图通过一定的协议和算法，使得分布式系统对于客户端能够提供一致的存储状态。该类系统通常有这样的定义
1. 所有节点的初始状态一致
2. 如果每个节点按照同样的顺序执行一串操作序列，那么最终的状态一致（复制状态机）

通常这类分布式系统的关键在于分布式系统的**操作序列以同样的顺序执行**，主要通过各种时间戳仿照行为实现。PAXOS和RAFT这种需要2f+1的节点基本上都是不考虑拜占庭问题的

##PAXOS
主要有两个角色：proposer和accpetor，proposer负责提出变更申请，而acceptor负责审核proposer提出来的变更请求，具体流程如图所示
![paxos](http://img.kuqin.com/upimg/allimg/141016/13003553S-0.png)
###阶段1
1. 一个proposer选择一个k值向大多数acceptor发出
2. acceptor根据接收到的k记录最大的给出承诺，不会接受比这个最大k小的请求
###阶段2
1. 当proposer接收到超过一半的同意请求，那么可以发出accpet请求，带上自己的V
2. accpetor只会接受当前最大的K，如果不是就拒绝accpet请求

从上面的过程需要注意几个点：
1. acceptor只会接受最大的k的proposal，但是proposal被拒绝了可以修改proposal的值重新发起，因此可能导致多个proposer不断的提交修改最大的K值从而永远无法被接收，这种情况称之为活锁，为了避免这种情况需要减少proposer，只推举少数leader
2. 每个proposer的k值需要唯一从而避免同样的k对应不同的v，其实这就是一种时间戳机制
zookeeper的leader选举是paxos实现，后续leader处理各个节点的同步请求是ZAB类似RAFT

*n/2+1节点正常就能够提供服务

##RAFT
跟paxos有点像却比paxos简单，RAFT吧PAXOS的leader优化发展到了极致，他的特点：
1. 强领导者（Strong Leader）：日志条目只从领导者发送向其他服务器。
2. 领导选取（Leader Selection）：Raft 使用随机定时器来选取领导者。

RAFT成员的三种状态：
1. leader：通过选举产生，接受所有客户端的同步请求再广播给所有follower
2. candidate：参加选举的服务器，选举成功后成为leader，这个状态持续时间一般非常短
3. follower：被动执行leader的请求

![转换关系](http://wx2.sinaimg.cn/mw690/4858d6a8ly1fc9uv9fx6wj20hn07xt9z.jpg)

RAFT通过任期（term，不断增加的数字）作为自己的时间戳，每个term的第一次操作都是选举leader，candidate只能给一个人投票‘，并且按照先来先投的原则，通过各种设定保证只能有一个人当选（随机超时，总有一个先达到“大多数”要求成为leader）。被选中的leader需要有完整（或者最完整）的操作列表。
选出leader后，leader开始接受客户端的请求，并且广播给所有follower进行appendEntries，只有当大多数follower执行该操作之后leader才会认为是commit的，如果有follower在commit之后被leader发现缺少操作也会被补操作。通常来说这种方式会保证leader和大多数follower的状态是一致的，但是在leader宕机follower还未执行完所有操作，可能会导致新选出来的leader和之前的leader的操作集存在一些问题，这个时候我们强制以新leader的操作集合为标准进行同步，因此leade是不会更改自己的操作集合的，只有follower为了完成一致而修改自己的操作集合。

*日志合并和快照机制来清理操作集合，n/2+1节点正常就能够提供服务

##PBFT

PBFT考虑的东西比PAXOS和RAFT多很多，因为他还考虑了节点不可信（发假消息，伪造消息）的情况，也就是所谓的拜占庭问题，在失效节点不超过f（还有f个可能无法响应，剩下的N-f可能会有F的fault节点发假消息，因此需要至少f+1个正常节点来维持工作，因此总节点至少为3f+1）的情况下仍能保持安全性和活性

特点：
1. 针对异步网络环境（请求响应的时长不确定，但最终总能响应）
2. 拜占庭容错，允许节点失效和伪造信息
3. 不能无限期的延迟消息应答
4. 不能破解加密算法

###活性和安全性保证
PBFT系统的活性和安全性依赖3F+1个副本数目（额外的副本会影响性能），针对安全性（就是序列化，算法本身可以保证，这里指的是恶意操作）是各个副本的状态最终一致，客户端可以通过观察执行结果和访问控制来限制恶意节点，活性（操作最终被执行）是依靠同步机制实现的，在PBFT中假设消息最终会被正确接收
1. 安全性：三阶段的一致性，视图变更的时候需要2f+1确认，执行操作(commit)需要２f+1个prepare，因为系统最多3f+1,所以保证有一个共有的non-fault节点的副本来保证安全性，视图切换需要重新执行之前的操作
2. 活性：主节点宕机后可以切换，但是也要防止视图切换过快（无法处理操作）简而言之就是系统能够提供服务，需要2f+1个视图切换消息，并且需要等待T时间超时，如果第一次失败下一次变成2T时间超时；选择最小视图编号来防止切换太晚；视图切换需要f+1个发起，如果fault节点是主节点也最多连续切换f次，因为视图切换是+1轮流来，除非超时太严重

PBFT算法的流程如下：
1. 客户端向主节点发送请求调用服务操作，请求带有时间戳来防止重复发和排序
2. 主节点开始对客户端的请求分配序号，并通过广播将预请求发送给其他副本（预准备）
3. 备份节点验证预准备消息，验证（签名、序号、水线）通过发送准备消息（准备）
4. 备份节点验证准备消息，验证通过后插入操作日志，并且发送执行结果（执行，commit执行需要接受2f+1个prepare,commit-local需要接受2f+1commit，其中可能包括自己） 
3. 所有副本都执行请求并将结果发回客户端
4. 客户端需要等待f+1个不同副本节点发回相同的结果，作为整个操作的最终结果。

*三阶段（预准备、准备、提交)都会在本地插入日志
*客户端可以在未确认上一条操作执行成功与否的情况下发起下一次请求

某一段时间内以来主副本存在，主副本的作用在于将来自Client的请求给排好序，然后按序发送给备份节点们。但是主节点可能会是faulty的：它可能会给不同的请求编上相同的序号，或者不去分配序号，或者让相邻的序号不连续。备份节点应当有职责来主动检查这些序号的合法性，并能通过timeout机制检测到主节点是否已经宕掉。当出现这些异常情况时，这些备份节点就会触发view change协议来选举出新的主节点，p=v mod n v自增（类似RAFT的leader）。
quorums有两个重要的属性：（1）Intersection： 任意两个quorums至少有一个共同的并且正确的replica；（2）Availability: 总是存在一个没有faulty replicas的quorum
如果一个replica把信息写给一个quorum，并让该quorum来存储信息，在收到每一个quorum中的成员的确认反馈后，那么我们可以认为该replica的信息已经被可靠的保存在了这个分布式系统中。这是强的约束，当然还有一个weak certificates：就是至少f+1个节点来共同存取信息，这样至少有一个正确的replica存到了这份信息。
算法的要求：
（1）所有节点必须是确定性的。也就是说，在给定状态和参数相同的情况下，操作执行的结果必须相同；（2）所有节点必须从相同的状态开始执行。在这两个限定条件下，即使失效的副本节点存在，PBFT算法对所有非失效副本节点的请求执行总顺序达成一致，从而保证安全性。

流程
![](http://img.mp.itc.cn/upload/20170526/b6b2c783ac6f4c0687543a5fc82fa405_th.jpg)

1. pre-prepare主副本接收到客户端的请求后，会给操作分配一个序号，然后发给所有其他副本，其他副本判断这个消息是否正确，如果接受则进入下一个阶段，记录日志
2. prepare：其他副本验证pre-prepare消息正确后广播自己接受了该分配方式，同时副本也会收到prepare消息根据自己的进行比较（需要2f+1的其他副本同意）记录日志
3. commit：prepare通过之后，发送自己的commit请求，一旦接收到2f+1个其他副本的commit请求，那么就认为该操作被认可，执行该操作

尾声：所有成功执行的节点把结果发回给客户端，客户端收到f+1个结果可以正确判断

**垃圾回收**：在某个操作中设置检查点（一般是某个常数k的倍数的操作），需要接受2f+1个确认信息清理检查点之前的操作日志，一般水线就是上一个保存点h到之后的第二个保存点h+2k

**自动切换主副本**：每个副本设置超时时间，当超过时候自动触发主副本切换协议，当主节点收到超过2f个view-change信息时，会广播一个new-view'消息，并且重新prepare一部分操作(上一个checkpoint到序号最大的prepare message)，跟RAFT重新选举leader有点像

即使主节点乱发消息，最终的结果也是一致的，不会结果不一致。有时候副本需要参与值的选取，那么就发2f+1个request，让副本可以从中选择执行

PBFT中消息的传递次数很多，不适合节点数目过多，对于带宽造成负担

###MAC（加密算法）
view change和new view用的一种特殊加密算法

###优化（减少通信）
1. 发送摘要来验证
2. 减少需要接受的消息数目2f+1
3. 只读操作不改变状态
