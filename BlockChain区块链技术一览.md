#BlockChain区块链技术一览
@(读书笔记)[分布式|一致性]
BlockChain区块链通常指的是通过一定的分布式时序机制,如POW(proof of work,工作量证明)的方式寻找合适的区块来存储数据,区块之间通过一定的顺序组织起来形成链式结构,从而实现分布式系统的一致性.

-------------------

[TOC]

##Bitcoin比特币
###电子交易的合法性验证
**电子现金(coin)**的交易可以抽象为这么一个过程;
1. **电子现金**的持有者通过对上笔交易和电子现金下一任拥有者的公钥进行散列,将该交易信息发给下一任拥有者
2. 下一任拥有者通过自己的私钥对该交易进行解密可以获得该**电子现金**.不持有私钥的用户即使拦截到交易信息也无法获得该**电子现金**

![比特币论文中给出模型](https://pic3.zhimg.com/80/v2-5c5286f04db038cfd25f479b3030f4da_hd.jpg)

该模型可以验证交易双方的正确性，但是如果持有者多次签发同一个**电子现金**，下一任拥有者在上述交易过程中无法识别该情形，会导致交易失败，这种多次支付通常被称之为**Double-Spending(双重支付)**.传统的解决方式是引入一个可信的**中央账本(mint)**去解决这个问题,如果**中央账本**存在,那么每一笔交易的情况均可以通过**中央账本**查询出来,因此用户无法发起虚假的交易而不被察觉.

比特币本质上为了解决无中心可信节点的网络架构下的**Double-Spending(双重支付)**问题的.首先给出**Double-Spending(双重支付)**的定义
>Double-spending is a potential flaw in a digital cash scheme in which the same single digital token can be spent more than once. This is possible because a digital token consists of a digital file that can be duplicated or falsified —— [维基百科Bitcoin](https://en.wikipedia.org/wiki/Double-spending)

由于电子现金容易复制的特点,在没有一个类似**中央账本**记录每笔交易的情况下,一个欺诈用户可能把同一笔电子现金支付给不同的商户而难以察觉.

抛开**中央账本**这个非常万金油的手段，我们来思考引起**双重支付**的本质原因：

>只要交易的接收者无法获得关于他即将接收到的**电子现金**的所有交易情况，就会给发起交易的人有机可趁。

因此解决手段也可以很简单，即使没有**中央账本**，我们只要让参与交易的每一位用户都能获取到所有的交易情况，那么**双重支付**难题便迎刃而解，问题退化为在分布式系统中维持可信**一致性**的问题。

###时序机制
无论是**PAXOS**,**RAFT**或者**PBFT**等分布式算法,算法的核心同样围绕着一致性的问题,而解决一致性的关键点在于建立一个全局唯一的**时序关系**,不管你有多少台机器,不管你的机器多么不稳定,只要我的算法规定必须按照统一的顺序执行所有的操作,那么全局的**一致性**最终必将实现.因此只要我们在电子现金交易的分布式系统中制定出一套**时序关系**,那么就能解决**一致性**问题

在**比特币**的论文中,作者给出了实现时序关系核心数据结构,就是著名的**BlochChain区块链**,其实**区块链**本质上是一种分布式系统的时间戳服务机制.首先给出作者对于区块链结构的描述
![区块链结构](https://pic1.zhimg.com/80/v2-293bebcf723e78e47c87372749e35769_hd.jpg)

所有的交易信息统一存放在区块之中.区块之间通过**时间戳**顺序相连,如图所示,上一个区块的**时间戳prev_timestamp**和本区块的**时间戳curr_timestamp**散列之后成为下一个区块的**时间戳prev_timstamp**,如此循环往复形成一条无限延长的链式结构,公式可以记为:

$$timestamp_{prev}(n+1) = hash(timestamp_{prev}(n) + timestamp_{curr}(n))$$

###工作量证明的意义
分布式系统中的物理时钟几乎没有任何意义的,此处提到的**时间戳**跟物理时钟几乎完全不相关,但是这种**时间戳**只要能够标识区块产生的**时序关系**,则足以满足**一致性**的需求.实现这种时间戳的方式则是**工作量证明POW**

本区块**时间戳curr_timestamp**在比特币中被定义为一个值**NONCE**,他的作用是使得**时间戳prev_timestamp**满足这么一个特点:**NONCE**和**时间戳prev_timestamp**一起通过特定的散列方法散列,该散列方法生成的散列值前面为若干个0,散列的结果为前面带有所需要个数0的数值则为我们需要的**NONCE**.

![区块链挖矿方式](https://pic3.zhimg.com/80/v2-dcd1e7c5ab9c5b92628b348a1c106126_hd.jpg)

我们重新把**时间戳prev_timestamp**表述为**Prev Hash**目标0的个数为**Target Zero**,对散列值求0的个数个方法称之为**GetZeroHeader**,获得区块的公式可以表述为

$$Target Zero = GetZeroHeader(hash(PrevHash+NONCE))$$

之所以叫**工作量证明POW**,是因为找到**NONCE**并不是一件简单的事情,需要大量的枚举才能得出,完成这一工作需要大量CPU算力.而验证只需要一次散列即可完成.找到这个**NONCE**之后,新的区块产生,区块内的交易被接入之前的区块之中,之后在产生的新区块后重复寻找**NONCE**的过程,从而生成更多的区块.如果有人想推翻之前的区块,给参与比特币运作的人造成困扰,他必须找到同样的**NONCE**去生成区块造成分叉.因此一般找到**NONCE**会异常艰难,从而阻止这样的事情发生

该方法跟传统的分布式一致性算法最大的区别在于:传统的一致性算法通过多人投票的方式来决定某一**时间戳**下的行为或者状态,这种一般是基于IP的,只要控制了多个IP,那么就能左右某一**时间戳**下的行为,通常情况下控制IP是比较容易的.而比特币是基于CPU算力的,只要算力够高就能左右某一**时间戳**下的行为.比特币把最长链当做大多数算力的决定,当绝大部分CPU算力被诚实节点控制的时候,一切都是有效的,攻击者为了修改区块需要付出高额的算力,通常来说也是不划算的.

由于硬件会不断升级,当区块增加速度过快说明当前的工作量已经不足以证明自己了,系统会调整找到特定值的难度,使得区块的生成稳定在一定的速度.

###节点的工作方式
比特币论文中每个节点的工作流程可以表述为:
1. 新的交易被广播给我所有节点
2. 每个节点收集接收到的交易,放到自己的区块中
3. 每个节点试图完成当前区块给定的工作量
4. 当某个节点完成工作量,那么 他把自己包含收集到的交易的区块信息广播出去
5. 当节点验证接收到的区块中的交易有效并且没有被使用过,那么接受该区块
6. 节点在接收到的有效区块之后继续尝试创造下一个区块,它使用的Prev Hash为接收到的有效区块

由于可能出现的同时找到**NONCE**的情况,允许临时的分叉,但是节点始终认为最长链为正确的**区块链**,因为不同的用户会在不同的区块中继续发掘下一个区块,这种分叉通常会在下一个区块被哪个分支最先发现而打破,因为其中一个分叉会成为最长链.

###比特币的产生和收益机制

比特币产生源于有效区块的产生,一旦发现一个有效区块,那么区块的发现者会奖励一定的比特币,随着区块的上升奖励的比特币的数目会下降到最后完全消失,这样是为了发行定量的比特币避免通货膨胀,所以比特币的总量是固定的.有效区块中存储的是比特币的交易记录.

每笔交易被区块收录的时候,交易的输入-输出剩下的那部分会作为交易费被区块的拥有者持有,因此即使最后不再产生新的比特币,只要比特币的交易仍在进行,那么发掘区块仍然是有利可图的.

通过这两种方式来奖励区块的发现者,也会是的区块的发现者更加倾向于成为一个诚实节点,因为诚实的行为会比**双重支付**的行为获得更多的利润.

###磁盘回收机制

分布式算法通常采用增量更新的方式来改变状态,操作数目会不断的增多,最终需要采取一定的回收机制来将过去的一些已经被大家确认不要的操作回收来节约磁盘空间.区块中的交易通过Merkle Tree组织,形如:
![Merkle Tree](https://pic4.zhimg.com/80/v2-ae384f96a100e86814ecdaf1dd559db1_hd.jpg)

比特币中的Merkle Tree是一种特殊的二叉树,叶子节点是每笔交易的hash值,交易hash值两两再hash形成他们的父亲节点,最终所有交易被hash为一个根节点放到区块头中,如果交易数目为奇数会人为的添加一笔交易使得Merkle Tree的建立.当一个比特币的最新一次交易被大多数区块收录后,他之前的交易会被从区块中拔除从而节约硬盘空间.其中区块头不会很大,甚至将所有的区块头全部放入内存中也是可行的.

###简化的支付验证机制和交易的合并分裂机制

即使一个比特币过去的交易记录被回收,只要上一次交易记录及其对应的分支存在
于硬盘空间中,新的关于该比特币的交易就可以通过验证上一次的分支是否能够一步一步hash到区块之中来验证该笔交易.

当节点需要验证交易是否合法时,他会首先确认自己获得了最长链,并且找到上一笔交易所在的区块以及Merkle Tree分支,他就能完成验证,该区块的后继区块也能说明了该区块的有效性.

由于他可能是需要通过其他节点来验证交易的有效性的,如果一个欺诈节点拥有高算力伪造了区块,那么会让验证机制变得脆弱,为了解决这个问题加入了一个报警机制,一旦发现可能有问题的区块将会通知全网对该区块进行检查.这个问题的存在使得一些商业机构更加倾向于拥有自己的一套节点来快速可信验证.

虽然可以对单个比特币进行交易,但是通常输入会是多个交易的输出,而输出只有两个,找零和支付

![enter image description here](https://pic3.zhimg.com/80/v2-1301b7719c240ffeb4d0cac63ba8d5a5_hd.jpg)

###数学上的简易证明

比特币的运行机制决定了财富不会被凭空创造(只有生成区块才能获得比特币)和掠夺别人的财富(私钥加密机制,无效的交易不会被诚实节点接受).欺诈者只能试图篡改自己的交易信息,比如**双重支付**,近似可以看成是赌徒破产模型:

>>The original meaning is that a persistent gambler who raises his bet to a fixed fraction of bankroll when he wins, but does not reduce it when he loses, will eventually and inevitably go broke, even if he has a positive expected value on each bet.              [赌徒破产模型](https://en.wikipedia.org/wiki/Gambler%27s_ruin)

简化描述为:不管赌徒的胜率如何,只要他以有限的财富去进行无限多次赌博,那么他最终会破产.

不太严谨的用平实的语言可以概述为:攻击者生成的伪造区块数目是有限的,诚实链条和攻击者之前产生下一个区块的概率分别为P,Q.攻击者先生成则加1,反之则减1.诚实链条通过不断的和攻击者进行博弈,最终抵消有限的伪造区块数目,使得攻击者计划破产.

##以太坊

在比特币的基础上做了一些改进，本身并没有相应的论文（有黄皮书）,他认为比特币原本的工作存在一些问题,主要有以下几点
1. **工作量证明**机制可以被定制的硬件快速破解，因此采用了对集成电路不敏感的**Dagger Hashimoto**算法。
2. 应用单一,因此给出了EVM

###Dagger Hashimoto

该算法主要有两个特点:
1. 防止特定集成电路攻击:采用特定集成电路和普通电脑的边际收益不会差别太大,**Hashimote**本身是一种依赖RAM的IO密集型的算法,而RAM读写速率基本上已经被优化至极限没有更快的可能性.
2. 轻客户端:客户端验证区块不麻烦,Dagger算法可以实现
3. 全链存储:挖矿依靠所有的链条的状态

**Dagger**的流程可以简述为:

1. 以一个特定的数作为图的起点,放入到图的节点队列中,
2. 通过某一个公式从节点队列中选取一个点作为父节点,通过特定公式基于父节点生成下一个节点,然后将子节点放入队列
3. 重复2过程特定次数得到一个有向无环图DAG

特定是父亲节点一致,那么可以生成一样的子树

**Hashimote**是从特定区块中提取参数作为父亲节点,从而推测出相应的字数和下一个NONCE,由于依赖一定的空间执行算法,可以防止特定集成电路攻击

###EVM
有一个特点是这个除了区块链之外还有自己的虚拟机**EVM**来运行特殊账户拥有一的段特殊的可执行代码(solidity),从而控制账户的行为,这个叫做contract(合约).为了避免合约中的运算被滥用,后来加入了Gas机制,每次运行合约需要"Gas fee" 油费，一般通过solidity编码实现

##Hyperledger

作者：maxdeath
链接：https://www.zhihu.com/question/48666841/answer/169774782
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

首先，链上有些chaincode（链码），可以理解为智能合约，总之是已经同意的逻辑。然后一笔交易可以指向并触发这些合约，然后得到一个输出，这个输出也会被写在交易里。此外，新版本相比于旧版本的变化是，整个网络的节点被分为两种（client我不认为是网络中的节点，因为不参与共识）。一种叫endorser（批准者），一种就是普通节点（peer）。此外还有某个叫做orderer（排序）的功能模块，有些节点可以身兼orderer，这个模块的主要功能是负责给交易排序和打包成区块。交易的过程是这样：1，首先，每个链码都有规定的批准者，假设我们考虑一个用于汽车交易的链码，它规定的批准者有A，B，C三个节点，比如说，这个链码规定了如下逻辑：这个交易生效的前提是A，B，C中的两个批准了这笔交易。2，这个时候，假设用户小明要买车，他生成一笔交易请求用于触发这个用于交易的链码，他把这个请求发给A，B，C三个节点等待批准。3，如果请求无误可信，A，B，C三个节点认可了这个请求，他们会直接进行运算生成结果然后写成交易反馈给用户（这个时候并不写入区块链，或者他们管这个叫账本）。4，用户收到返回的交易之后，如果确认返回的交易结果一致，则把交易发给排序模块，然后排序模块将所有收到的交易根据时间排序，打包形成区块，然后发给所有节点。注意，这里排序模块不对交易进行任何验证，也就是不管他们收到的交易是不是得到了足够的批准，只要格式对，他们都打包进区块。5，所有节点验证每笔交易是不是得到了足够的批准，如果是，则注明有效交易，否则著名无效交易，但不论结果如何，所有交易都会被写进账本。6，最后，如果交易成功，节点通知用户交易已经加入账本。相比于之前的版本，v1多了这些东西：1，排序模块从逻辑上被拆了出来，然而实际上节点可以兼职排序。2，多了批准者这个东西，也就是说，只有批准者会知道你的交易的详情，而其他节点在验证的时候只验证是不是得到了规定的批准者的批准。3，我这里没写，但是多了一个叫通道的东西，不同的通道本质上就是不同的独立的区块链。

##Algorand
根据VRF选出一系列参选者，最后在参选者之中选出领导者，然后运行BA（拜占庭算法）
https://zhuanlan.zhihu.com/p/29429006

##GETH
用Go实现的以太坊

主要通过solidity编程来完成智能合约
编写代码放到区块上通过Remix编写，在生成相应的接口信息（ABI和deploy信息）
别人通过区块地址address和相应的接口调用相应ABI方法去调用并得到结果，注意是方法名.call





