#BlockChain区块链技术一览
@(读书笔记)[分布式|一致性]
BlockChain区块链通常指的是通过一定的分布式时序机制,如POW(proof of work,工作量证明)的方式寻找合适的区块来存储数据,区块之间通过一定的顺序组织起来形成链式结构,从而实现分布式系统的一致性.

-------------------

[TOC]

##Bitcoin比特币
###电子交易的合法性验证
**电子现金(coin)**的交易可以抽象为这么一个过程;
1. **电子现金**的持有者通过对上笔交易和电子现金下一任拥有者的公钥进行散列,将该交易信息发给下一任拥有者
2. 下一任拥有者通过自己的私钥对该交易进行解密可以获得该**电子现金**.不持有私钥的用户即使拦截到交易信息也无法获得该**电子现金**

![比特币论文中给出模型](https://pic3.zhimg.com/80/v2-5c5286f04db038cfd25f479b3030f4da_hd.jpg)

该模型可以验证交易双方的正确性，但是如果持有者多次签发同一个**电子现金**，下一任拥有者在上述交易过程中无法识别该情形，会导致交易失败，这种多次支付通常被称之为**Double-Spending(双重支付)**.传统的解决方式是引入一个可信的**中央账本(mint)**去解决这个问题,如果**中央账本**存在,那么每一笔交易的情况均可以通过**中央账本**查询出来,因此用户无法发起虚假的交易而不被察觉.

比特币本质上为了解决无中心可信节点的网络架构下的**Double-Spending(双重支付)**问题的.首先给出**Double-Spending(双重支付)**的定义
>Double-spending is a potential flaw in a digital cash scheme in which the same single digital token can be spent more than once. This is possible because a digital token consists of a digital file that can be duplicated or falsified —— [维基百科Bitcoin](https://en.wikipedia.org/wiki/Double-spending)

由于电子现金容易复制的特点,在没有一个类似**中央账本**记录每笔交易的情况下,一个欺诈用户可能把同一笔电子现金支付给不同的商户而难以察觉.

抛开**中央账本**这个非常万金油的手段，我们来思考引起**双重支付**的本质原因：

>只要交易的接收者无法获得关于他即将接收到的**电子现金**的所有交易情况，就会给发起交易的人有机可趁。

因此解决手段也可以很简单，即使没有**中央账本**，我们只要让参与交易的每一位用户都能获取到所有的交易情况，那么**双重支付**难题便迎刃而解，问题退化为在分布式系统中维持可信**一致性**的问题。

###时序机制
无论是**PAXOS**,**RAFT**或者**PBFT**等分布式算法,算法的核心同样围绕着一致性的问题,而解决一致性的关键点在于建立一个全局唯一的**时序关系**,不管你有多少台机器,不管你的机器多么不稳定,只要我的算法规定必须按照统一的顺序执行所有的操作,那么全局的**一致性**最终必将实现.因此只要我们在电子现金交易的分布式系统中制定出一套**时序关系**,那么就能解决**一致性**问题

在**比特币**的论文中,作者给出了实现时序关系核心数据结构,就是著名的**BlochChain区块链**,其实**区块链**本质上是一种分布式系统的时间戳服务机制.首先给出作者对于区块链结构的描述
![区块链结构](https://pic1.zhimg.com/80/v2-293bebcf723e78e47c87372749e35769_hd.jpg)

所有的交易信息统一存放在区块之中.区块之间通过**时间戳**顺序相连,如图所示,上一个区块的**时间戳prev_timestamp**和本区块的**时间戳curr_timestamp**散列之后成为下一个区块的**时间戳prev_timstamp**,如此循环往复形成一条无限延长的链式结构,公式可以记为:

$$timestamp_{prev}(n+1) = hash(timestamp_{prev}(n) + timestamp_{curr}(n))$$

###工作量证明的意义
分布式系统中的物理时钟几乎没有任何意义的,此处提到的**时间戳**跟物理时钟几乎完全不相关,但是这种**时间戳**只要能够标识区块产生的**时序关系**,则足以满足**一致性**的需求.实现这种时间戳的方式则是**工作量证明POW**

本区块**时间戳curr_timestamp**在比特币中被定义为一个值**NONCE**,他的作用是使得**时间戳prev_timestamp**满足这么一个特点:**NONCE**和**时间戳prev_timestamp**一起通过特定的散列方法散列,该散列方法生成的散列值前面为若干个0,散列的结果为前面带有所需要个数0的数值则为我们需要的**NONCE**.

![区块链挖矿方式](https://pic3.zhimg.com/80/v2-dcd1e7c5ab9c5b92628b348a1c106126_hd.jpg)

我们重新把**时间戳prev_timestamp**表述为**Prev Hash**目标0的个数为**Target Zero**,对散列值求0的个数个方法称之为**GetZeroHeader**,获得区块的公式可以表述为

$$Target Zero = GetZeroHeader(hash(PrevHash+NONCE))$$

之所以叫**工作量证明POW**,是因为找到**NONCE**并不是一件简单的事情,需要大量的枚举才能得出,完成这一工作需要大量CPU算力.而验证只需要一次散列即可完成.找到这个**NONCE**之后,新的区块产生,区块内的交易被接入之前的区块之中,之后在产生的新区块后重复寻找**NONCE**的过程,从而生成更多的区块.如果有人想推翻之前的区块,给参与比特币运作的人造成困扰,他必须找到同样的**NONCE**去生成区块造成分叉.因此一般找到**NONCE**会异常艰难,从而阻止这样的事情发生

该方法跟传统的分布式一致性算法最大的区别在于:传统的一致性算法通过多人投票的方式来决定某一**时间戳**下的行为或者状态,这种一般是基于IP的,只要控制了多个IP,那么就能左右某一**时间戳**下的行为,通常情况下控制IP是比较容易的.而比特币是基于CPU算力的,只要算力够高就能左右某一**时间戳**下的行为.比特币把最长链当做大多数算力的决定,当绝大部分CPU算力被诚实节点控制的时候,一切都是有效的,攻击者为了修改区块需要付出高额的算力,通常来说也是不划算的.

由于硬件会不断升级,当区块增加速度过快说明当前的工作量已经不足以证明自己了,系统会调整找到特定值的难度,使得区块的生成稳定在一定的速度.

###节点的工作方式
比特币论文中每个节点的工作流程可以表述为:
1. 新的交易被广播给我所有节点
2. 每个节点收集接收到的交易,放到自己的区块中
3. 每个节点试图完成当前区块给定的工作量
4. 当某个节点完成工作量,那么 他把自己包含收集到的交易的区块信息广播出去
5. 当节点验证接收到的区块中的交易有效并且没有被使用过,那么接受该区块
6. 节点在接收到的有效区块之后继续尝试创造下一个区块,它使用的Prev Hash为接收到的有效区块

由于可能出现的同时找到**NONCE**的情况,允许临时的分叉,但是节点始终认为最长链为正确的**区块链**,因为不同的用户会在不同的区块中继续发掘下一个区块,这种分叉通常会在下一个区块被哪个分支最先发现而打破,因为其中一个分叉会成为最长链.

###比特币的产生和收益机制

比特币产生源于有效区块的产生,一旦发现一个有效区块,那么区块的发现者会奖励一定的比特币,随着区块的上升奖励的比特币的数目会下降到最后完全消失,这样是为了发行定量的比特币避免通货膨胀,所以比特币的总量是固定的.有效区块中存储的是比特币的交易记录.

每笔交易被区块收录的时候,交易的输入-输出剩下的那部分会作为交易费被区块的拥有者持有,因此即使最后不再产生新的比特币,只要比特币的交易仍在进行,那么发掘区块仍然是有利可图的.

通过这两种方式来奖励区块的发现者,也会是的区块的发现者更加倾向于成为一个诚实节点,因为诚实的行为会比**双重支付**的行为获得更多的利润.

###磁盘回收机制

分布式算法通常采用增量更新的方式来改变状态,操作数目会不断的增多,最终需要采取一定的回收机制来将过去的一些已经被大家确认不要的操作回收来节约磁盘空间.区块中的交易通过Merkle Tree组织,形如:
![Merkle Tree](https://pic4.zhimg.com/80/v2-ae384f96a100e86814ecdaf1dd559db1_hd.jpg)

比特币中的Merkle Tree是一种特殊的二叉树,叶子节点是每笔交易的hash值,交易hash值两两再hash形成他们的父亲节点,最终所有交易被hash为一个根节点放到区块头中,如果交易数目为奇数会人为的添加一笔交易使得Merkle Tree的建立.当一个比特币的最新一次交易被大多数区块收录后,他之前的交易会被从区块中拔除从而节约硬盘空间.其中区块头不会很大,甚至将所有的区块头全部放入内存中也是可行的.

###简化的支付验证机制和交易的合并分裂机制

即使一个比特币过去的交易记录被回收,只要上一次交易记录及其对应的分支存在
于硬盘空间中,新的关于该比特币的交易就可以通过验证上一次的分支是否能够一步一步hash到区块之中来验证该笔交易.

当节点需要验证交易是否合法时,他会首先确认自己获得了最长链,并且找到上一笔交易所在的区块以及Merkle Tree分支,他就能完成验证,该区块的后继区块也能说明了该区块的有效性.

由于他可能是需要通过其他节点来验证交易的有效性的,如果一个欺诈节点拥有高算力伪造了区块,那么会让验证机制变得脆弱,为了解决这个问题加入了一个报警机制,一旦发现可能有问题的区块将会通知全网对该区块进行检查.这个问题的存在使得一些商业机构更加倾向于拥有自己的一套节点来快速可信验证.

虽然可以对单个比特币进行交易,但是通常输入会是多个交易的输出,而输出只有两个,找零和支付

![enter image description here](https://pic3.zhimg.com/80/v2-1301b7719c240ffeb4d0cac63ba8d5a5_hd.jpg)

###数学上的简易证明

比特币的运行机制决定了财富不会被凭空创造(只有生成区块才能获得比特币)和掠夺别人的财富(私钥加密机制,无效的交易不会被诚实节点接受).欺诈者只能试图篡改自己的交易信息,比如**双重支付**,近似可以看成是赌徒破产模型:

>>The original meaning is that a persistent gambler who raises his bet to a fixed fraction of bankroll when he wins, but does not reduce it when he loses, will eventually and inevitably go broke, even if he has a positive expected value on each bet.              [赌徒破产模型](https://en.wikipedia.org/wiki/Gambler%27s_ruin)

简化描述为:不管赌徒的胜率如何,只要他以有限的财富去进行无限多次赌博,那么他最终会破产.

不太严谨的用平实的语言可以概述为:攻击者生成的伪造区块数目是有限的,诚实链条和攻击者之前产生下一个区块的概率分别为P,Q.攻击者先生成则加1,反之则减1.诚实链条通过不断的和攻击者进行博弈,最终抵消有限的伪造区块数目,使得攻击者计划破产.